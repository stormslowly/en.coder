这是我听过说 git 坏话说得最好的

Hello World. 大家好, 我是 pshu. 今天是码农英语课堂的第10期了.
虽然更新的稀稀拉拉的, 自己终于坚持到了10期. 在此也感谢各位朋友的支持和鼓励.

秉承节目扯淡十万八千里的特色,还是先不说今天的主角 Git 和另外一位神秘主角.

# 扯

海尔布隆的幽灵(Phantom /ˈfan(t)əm/  of Heilbronn)
https://www.wikiwand.com/en/Phantom_of_Heilbronn

首先这是一个真实的故事.

1993, 在德国一个62的妇女在家中被杀, 然后在家中的杯子上发现了一个 DNA 的样本. 这个样本在2001年被分析,
可以断定 DNA 来自一个年轻女性. 那在接下来7年时间, 这个神秘的女性不断在德国作案, 甚至法国也发现了她的
DNA. 其中最让德国警方震怒的是在2007年一位海尔布隆的女警员被杀害, 这个简直就是在挑衅警方啊!
由于长期不能缉拿凶手这个神秘女性就被称为 phantom of heilbronn (海尔布隆的幽灵).

最后在2009年的时候,出现了一件非常匪夷所思的事情. 在法国一个男性的烧焦的尸体也发现了相同的基因.
问题就来了啊, 这个死者是男性啊? DNA怎么是女性呢?

最后,重新分析了整个事件,发现这个 DNA 是来自来提取一个棉签棒工厂的女工身上. 原来用来提取 DNA 的棉签棒
在生产的时候, 棉签棒被污染, 导致后来的 DNA 检测全部出错. 之所以欧洲其他国家也出现这个 DNA 的原因就很简单,用了一样的牌子的.


在各种不同的犯罪场景下, 这么一致的作案者. 这里肯定就出来什么问题. 这就是我要说的"一致性的矛盾"的概念.
一致性的矛盾原本是心理学上的一个概念,如果对同一个人的在不同环境和不同观察者的人格评定下如果发现一致的性格; 那这个评定的结果是有问题的.

推广到更广泛的领域的情况, 如果一个事物大家都有一致的结论那么我们就要怀疑这个结论.


# 扯回来

回到我们今天要说的二号主角 Git, 现在要是提到版本管理, 估计会得到"一致"的推荐 Git.

pshu 分享最近看到的一篇老文章 "Why SQLite Does Not Use Git", SQLite 没什么不用 git 作为版本管理工具, 而是用 fossil /ˈfɒsɪl/  来管理 SQLite 的代码.

这个 fossil 也是一个版本管理工具, 它的一些特性后面 pshu 和你慢慢说. 说下 Git 和 fossil
在开发时一个非常有意思的实践: dogfooding. Linus 在开发的 git 时候,
几天之后就用开发中的 git 来管理 git 本身的代码了; 而 fossil 是基于 SQLite 来开发,而 fossil
的数据存储是使用的 SQLite的. 让自己成为自己开发的产品的第一批用户的实践, 我们称为 dogfooding.

回到这篇文章, 文中提到下面5个方面没有选择 Git.

## 1. git 查看一个提交后继的提交比较麻烦.

git commit 对象决定了 git 在访问一个提交的上一个提交的时候非常的方便, 但是要访问一个提交的"后继者"
的时候非常的麻烦, 文章里面给出了一个各种命令管道组合起来的方式来访问, 但是这么麻烦显然是反人类的.

```
git rev-list --all --parents | grep ".\{40\}.*.*" | awk '{print $1}'
```

当然也有一些方法让查看之后的提交更加方便的方法,比如写一个 shell 脚本, 但是重点不在于次. SQLite 看重的是, 在 fossil 中查看提交的时候, 能给出了这个提交的上下文信息. 这样的话, 维护开发人员能够更加
方便的知道当时发生了什么.

## 2. git 的心理模型过于复杂

所有为软件开发服务的软件首要的任务是让开发人员尽快的进入到开发状态, 毕竟开发人员的注意力有限.
git 中文件状态的概念, local remote 的概念确实需要先理解理解. 而 fossil 直接关注
目录和当前提交, 节省了开发人员大量的脑力(brain-cycle).

那些 Git 用户鄙视 SVN 用户的鄙视链条上的人, 往往忽略了我们使用这些东西的目的是什么. 如果目的达到了
鄙视不是鄙视都没有意义, 如果目的都没有达到那就是五十步笑百步.


## 3. git 对分支的记录太简陋了

这里稳重举了一个例子, SQLite 开发的同一个分支,在 github 上显示的分支信息和 fossil 自带的 Web UI 显示的分支信息对比,可以看到 fossil 记录了分支在开发中很多的历史信息, 比如从 master 分支两次合并过来, 最终分支又合并到回了 master 分支. 而在 github 的页面上看不到这些信息.

这也是印着了一个说法就是 git 只是记录了你完成了什么 (what you have done) 而 fossil 记录的则是
你做了什么(what you did)


## 4. git 需要多的运维需求.

这里 pshu 意译了下, 原文的是说需要更多的 "administrative support". 原文说的是系统总使用 git 需要
一个安装程序, 升级也非常麻烦.(其实个人觉得现在各个软件管理程序非常方便,安装一个 git 还是很简单的,  a piece of cake). 关键虽然 git 是分布式的, 但是你还是需要一个托管的服务器, 用 github 就引入了一个新
的依赖, 如果需要自己安装 gitlab 就需要更多的依赖. 所以要用 git 协作开发还是需要运维的支持.

但是如果使用 fossil 的话, 只需要的一个 fossil 的可执行文件放到 $PATH 下就可以了. 而且这个 fossil 文件除了提供 git 版本管理的功能外,还是有 github/gitlab 中的 wiki 和 issue 功能. 是的, 我没有说错
一个简单的 fossil 就提供如此丰富的功能.


## 5. git 太难用了.

这个漫画里面的事情真的在我的身边发生过.
记得还在网上看过一个段子是说 git 非常好,但是只有一个缺点.

> you don't know how to use git without a search engine.
> 没有搜索引擎的话,就不知道怎么用 git.


# 总结

好了,文章大意说完了. 介绍这篇文章的目的,并不是说让大家马上放弃 git 去使用 fossil.
只是想在"一致"喜爱 git 的大环境下, 告诉大家还有一些其他的选择 fossil/mercurial 等等.

当你发现周围都是和你一样观点的时候, 可以适当的怀疑下你的观点.
当你发现周围有和你不一样观点的时候, 开放你的思想兼容并包一下.

蔡元培照片

happy git and happy fossil.
